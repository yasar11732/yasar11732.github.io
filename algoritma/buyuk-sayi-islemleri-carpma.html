<!DOCTYPE html>
<html prefix="            og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="tr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Büyük Sayı Algoritmaları - Çarpma | YSAR.NET</title>
<link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700,900%7CUbuntu:300,400,500,700" rel="stylesheet">
<link href="../assets/icons/foundation-icons.css" rel="stylesheet" type="text/css">
<link href="../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../assets/css/style.css" rel="stylesheet" type="text/css">
<script defer src="../assets/js/misc.js"></script><meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml">
<link rel="canonical" href="http://ysar.net/algoritma/buyuk-sayi-islemleri-carpma.html">
<!--[if lt IE 9]><script src="../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Yaşar Arabacı">
<link rel="prev" href="buyuk-sayi-islemleri-toplama-cikarma.html" title="Büyük Sayı Algoritmaları - Toplama / Çıkarma" type="text/html">
<link rel="next" href="rastgele-sayi-uretici.html" title="Rastgele Sayı Üretici" type="text/html">
<meta property="og:site_name" content="YSAR.NET">
<meta property="og:title" content="Büyük Sayı Algoritmaları - Çarpma">
<meta property="og:url" content="http://ysar.net/algoritma/buyuk-sayi-islemleri-carpma.html">
<meta property="og:description" content="Bir önceki yazıda, n-haneli doğal sayılar üzerinde toplama
çıkarma algoritmalarından bahsetmiştik. Bu yazıda m-haneli doğal sayılar ile n-haneli doğal sayılar arasında
çarpma işlemi yapan bir algoritm">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-02-26T22:44:00+03:00">
<meta property="article:tag" content="mathjax">
</head>
<body>

         
    <header class="fixed-top"><div class="container">
        <a href="http://ysar.net">
            <img class="logo" src="../assets/img/Logo.svg"></a>
        <div class="subtitle">Python, Yazılım ve Programlama</div>
    <nav id="menu"><ul>
<li class="fi-info"><a href="../yasar-arabaci.html">Hakkımda</a></li>
            <li class="fi-social-github"><a href="https://github.com/yasar11732/">GitHub</a></li>
            <li class="question"><a href="../soru-cevap.html">Soru-Cevap</a></li>
            <li class="fi-rss"><a href="../rss.xml">RSS</a></li>
        </ul></nav>
</div>
        
    </header><main class="main-content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 itemprop="headline name">Büyük Sayı Algoritmaları - Çarpma</h1>

        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p><a href="buyuk-sayi-islemleri-toplama-cikarma.html">Bir önceki yazıda</a>, n-haneli doğal sayılar üzerinde toplama
çıkarma algoritmalarından bahsetmiştik. Bu yazıda m-haneli doğal sayılar ile n-haneli doğal sayılar arasında
çarpma işlemi yapan bir algoritmayı inceleyeceğiz. Bu algoritmanın ön çalışması olarak, bir haneli iki
sayı çarparak, iki haneli sonuç döndüren bir fonksiyon yazacağız. </p>
<pre class="code literal-block"><span></span><span class="kt">void</span> <span class="nf">bn_mul_n11</span><span class="p">(</span><span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">rl</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="n">op1</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bn_digit_t</span> <span class="n">op1_h</span> <span class="o">=</span> <span class="p">(</span><span class="n">op1</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">BN_DIGIT_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
    <span class="n">bn_digit_t</span> <span class="n">op1_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">op1</span> <span class="o">&amp;</span> <span class="n">BN_DIGIT_LOWMASK</span><span class="p">);</span>
    <span class="n">bn_digit_t</span> <span class="n">op2_h</span> <span class="o">=</span> <span class="p">(</span><span class="n">op2</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">BN_DIGIT_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
    <span class="n">bn_digit_t</span> <span class="n">op2_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">op2</span> <span class="o">&amp;</span> <span class="n">BN_DIGIT_LOWMASK</span><span class="p">);</span>

    <span class="n">bn_digit_t</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">op1_l</span> <span class="o">*</span> <span class="n">op2_l</span><span class="p">;</span>
    <span class="n">bn_digit_t</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">op1_l</span> <span class="o">*</span> <span class="n">op2_h</span><span class="p">;</span>
    <span class="n">bn_digit_t</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">op1_h</span> <span class="o">*</span> <span class="n">op2_l</span><span class="p">;</span>
    <span class="n">bn_digit_t</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">op1_h</span> <span class="o">*</span> <span class="n">op2_h</span><span class="p">;</span>

    <span class="n">p2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">BN_DIGIT_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
    <span class="n">p2</span> <span class="o">+=</span> <span class="n">p3</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;</span> <span class="n">p3</span><span class="p">)</span> <span class="c1">// carry</span>
    <span class="p">{</span>
        <span class="n">p4</span> <span class="o">+=</span> <span class="n">BN_DIGIT_HI</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">BN_DIGIT_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&amp;</span> <span class="n">BN_DIGIT_LOWMASK</span><span class="p">);</span>
    <span class="n">rl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p4</span> <span class="o">+</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">BN_DIGIT_BITS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</pre>


<p>32 bit iki sayının çarpımı, 64 bite kadar sonuç verebileceği için, 32 bitlik
çarpanları, 16 bitlik parçalara bölüp, parçaları ikişerli olarak çarpıp,
elde ettiğimiz sonuçları farklı oranlarda kaydırarak toplayıp, 2 haneli bir
sonuç elde edebilir. Kaydırma oranlarıyla ilgili olarak, aşağıdaki tabloyu
inceleyebilirsiniz.</p>
<pre>
64      48      32      16      0
+---------------+-------+-------+
|op1_h x op2_h  |       |       |
+-------+-------+-------+-------+
|       |op1_h x op2_l  |       |
+-------+---------------+-------+
|       |op1_l x op2_h  |       |
+-------+-------+-------+-------+
|               |op1_l x op2_l  |
+---------------+---------------+
</pre>

<p>Bunun neden işe yaradığını anlamak için, 32 bit \(u\) ve \(v\) sayılarını çarptığımızı
varsayalım. \(u_h\) sayının 16 bitlik üst kısmını, \(u_l\) ise sayının 16 bitlik alt kısmını
temsil etsin.</p>
<div>
$$
\begin{align}
u &amp; = 2^{16} * u_h + u_l \\
v &amp; = 2^{16} * v_h + v_l \\
u * v &amp; = (2^{16} * u_h + u_l) * (2^{16} * v_h + v_l) \\
 &amp; = 2^{32} * u_h * v_h + 2^{16} * u_h * v_l + 2^{16} * v_h * u_l + u_l * v_l \\
\end{align}
$$
</div>

<p>Yukarıdaki fonksiyon genel olarak genişleyen (argümanlarından geniş sonuç veren) çarpma
işlemlerinde kullanılabilir. Ancak, birçok modern 32 bit işlemci, 64 bit sonuç verebiliyor.
64 bit işlemcilerde zaten böyle bir sorunumuz olmadığı için, aşağıdaki fonksiyon çoğunlukla
yukarıdakinden daha iyi bir performans verecektir.</p>
<pre class="code literal-block"><span></span><span class="kt">void</span> <span class="nf">bn_mul_n11</span><span class="p">(</span><span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">rl</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="n">op1</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="p">((</span><span class="n">bn_long_digit_t</span> <span class="o">*</span><span class="p">)</span><span class="n">rl</span><span class="p">)</span> <span class="o">=</span> <span class="p">((</span><span class="n">bn_long_digit_t</span><span class="p">)</span><span class="n">op1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">bn_long_digit_t</span><span class="p">)</span><span class="n">op2</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<p>1-hane x 1-hane çarpımı yaptıktan sonra, n-hane x 1-hane çarpımına geçebiliriz. Bir önceki yazıda egzersiz
olarak bıraktığım, n-haneli ve 1 haneli toplamı fonksiyonunu da burada tanımlıyorum.</p>
<pre class="code literal-block"><span></span><span class="n">bn_digit_t</span> <span class="nf">bn_add_n1</span><span class="p">(</span><span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="k">const</span> <span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="n">op2</span><span class="p">,</span> <span class="n">bn_size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bn_size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">op1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
    <span class="n">bn_digit_t</span> <span class="n">carry</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">op2</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">carry</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">carry</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bn_digit_t</span> <span class="nf">bn_mul_n1</span><span class="p">(</span><span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="n">op2</span><span class="p">,</span> <span class="n">bn_size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bn_digit_t</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">bn_digit_t</span> <span class="n">carry</span><span class="p">;</span>
    <span class="n">bn_size_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">bn_mul_n11</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">op1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">op2</span><span class="p">);</span>
        <span class="n">bn_add_n1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">carry</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// bu carry döndüremez, döndürmemeli</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">carry</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Burada <code>for</code> döngüsünün her bir adımında, <code>op1</code>'in bir hanesi ile, <code>op2</code>'yi
çarpıyoruz. Bu çarpım bize 2 haneli bir sonuç veriyor. Bu sonuca, bir önceki
döngüden devir aldığımız sayıyı ekliyoruz. Elde ettiğimiz sonucun küçük hanesini
sonuç olarak yazıp, büyük hanesini bir sonraki döngü adımına devrediyoruz. Aynı
algoritmanın, onluk tabanda 7381 ile 5 arasında uygulanmış halini aşağıdaki
gibi çalışacaktır.</p>
<pre>
i = 0, carry = 0: 1 x 5 = 5, 5 + 0 = 5 -&gt; Sonuç[0] = 5, carry = 0
i = 1, carry = 0: 8 x 5 = 40, 40 + 0 = 40 -&gt; Sonuç[1] = 0, carry = 4
i = 2, carry = 4: 3 x 5 = 15, 15 + 4 = 19 -&gt; Sonuç[2] = 9, carry = 1
i = 3, carry = 1: 7 x 5 = 35, 35 + 1 = 36 -&gt; Sonuç[3] = 6, carry 3

Döngü Sonu: Sonuç[4] = 3
Döndüreceğimiz Değer: 36905

   7381
x     5
-- -- --
     05
    40
   15
+ 35
-- -- --
  36905
</pre>

<p>Son algoritmaya geçmeden önce, yukarıdaki fonksiyonun farklı bir versiyonunu
yazalım. Bu fonksiyonun öncekinden farkı, çarpım sonucunu, <code>result</code> array'inde
önceden bulunan değerin üstüne ekliyor olması. </p>
<pre class="code literal-block"><span></span><span class="c1">// result += op1 * op2</span>
<span class="n">bn_digit_t</span> <span class="nf">bn_muladd_n1</span><span class="p">(</span><span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="n">op2</span><span class="p">,</span> <span class="n">bn_size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bn_digit_t</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">bn_digit_t</span> <span class="n">carry</span><span class="p">;</span>
    <span class="n">bn_size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">bn_mul_n11</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">op1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">op2</span><span class="p">);</span>
        <span class="n">bn_add_n1</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">carry</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">carry</span> <span class="o">+=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">carry</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Şu ana kadar yazdığımız fonksiyonları kullanarak, m-haneli ve n-haneli sayilari
çarpan fonksiyona geçebiliriz.</p>
<pre class="code literal-block"><span></span><span class="kt">void</span> <span class="nf">bn_mul_n</span><span class="p">(</span><span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">bn_size_t</span> <span class="n">m</span><span class="p">,</span> <span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">op2</span><span class="p">,</span> <span class="n">bn_size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bn_size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">result</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">bn_mul_n1</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span><span class="o">++</span><span class="p">;</span>
        <span class="n">op2</span><span class="o">++</span><span class="p">;</span>

        <span class="n">result</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">bn_muladd_n1</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>


<p>Bu fonksiyonda, önce <code>op2</code>'nin son hanesi ile, <code>op1</code>'i çarpıp, sonucu <code>result</code> array'ine yazıyoruz.
<code>for</code> döngüsünün her bir adımında, <code>op2</code> bir sonraki hanesini <code>op1</code> ile çarparak, <code>result</code>
array'inin bir sonraki hanesine ekliyoruz. Döngünün her girişinde <code>result</code> pointer'ını bir artırdığımıza
dikkat edin. Böylece, <code>op2</code>'nin her hanesinin çarpımını, sonuca kaydırarak eklemiş oluyoruz. Örneğin, onluk
tabanda 565 ile 17'nin çarpımını aşağıdaki gibi hayal edebilirsiniz.</p>
<pre>
    567
x    17
-- -- -
   3969
+ 0567
-- -- -
  09639
</pre>

<p>Bir önceki yazıda, egzersiz olarak bıraktığım farklı büyüklükteki doğal sayıları toplama fonksiyonu da şu şekilde yazılabilir</p>
<pre class="code literal-block"><span></span><span class="n">bn_digit_t</span> <span class="nf">bn_add_nn</span><span class="p">(</span><span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="k">const</span> <span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">bn_size_t</span> <span class="n">n1</span><span class="p">,</span> <span class="k">const</span> <span class="n">bn_digit_t</span> <span class="o">*</span><span class="n">op2</span><span class="p">,</span> <span class="n">bn_size_t</span> <span class="n">n2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bn_digit_t</span> <span class="n">carry</span> <span class="o">=</span> <span class="n">bn_add_n</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">n2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n2</span><span class="p">)</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">bn_add_n1</span><span class="p">(</span><span class="n">result</span> <span class="o">+</span> <span class="n">n2</span><span class="p">,</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span><span class="p">,</span> <span class="n">carry</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">carry</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h3>Ek Kaynaklar</h3>
<ul>
<li>Knuth D. Art of The Computer Programming Vol 2 Section 4.3.1</li>
<li><a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba algorithm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Toom%E2%80%93Cook_multiplication">Toom–Cook multiplication</a></li>
<li>x86 Instruction Set Reference <a href="https://x86.puri.sm/html/file_module_x86_id_210.html">MUL</a>
</li>
</ul>
</div>
    </div>
    <aside class="postpromonav"><nav><div class="pager">
                <a href="buyuk-sayi-islemleri-toplama-cikarma.html" rel="prev" title="Büyük Sayı Algoritmaları - Toplama / Çıkarma">Önceki yazı</a>
                <a href="rastgele-sayi-uretici.html" rel="next" title="Rastgele Sayı Üretici">Sonraki yazı</a>
        </div>

    </nav></aside><script src="https://utteranc.es/client.js" repo="yasar11732/yasar11732.github.io" issue-term="title" theme="github-light" crossorigin="anonymous" async>
	</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-SDRP1VVYu+tgAGKhddBSl5+ezofHKZeI+OzxakbIe/Y=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']]}});
        </script></article></main><script>
  if(document.location.hostname == "ysar.net")
  {
      (function() {
        var cx = '013136674562336859018:ouohwab0yku';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
            '//www.google.com/cse/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
      
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-44774134-1', 'auto');
          ga('send', 'pageview');
  }

</script>
</body>
</html>
